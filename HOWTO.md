### 1. Правила участия в конкурсе

Для того чтобы начать, %username%, расчехли свою любимую IDE и скачай архив с тестовыми [данными](#entities) в формате JSON с сайта проведения конкурса [https://highloadcup.ru](https://highloadcup.ru). Тебе необходимо сначала создать, а затем и развернуть производительный сервер приложения, который будет реализовывать необходимое Web API к этим данным.

Ты можешь использовать любые веб-технологии, которые сможешь найти или придумать. Выбери свой собственный язык программирования и фреймворк. Это может быть C++, Java + Tomcat, Python + Django, Ruby + RoR, GoLang, JavaScript + NodeJs, Haskell или что-то еще, на твоё усмотрение. Также и для хранения данных: MySQL, PostgreSQL, Redis, MongoDB, кэши - up-to-you! Обрати внимание, **в конкурсе оценивается не только кол-во верных ответов на запросы, но и скорость работы сервера** - выбирай осторожно!

Сначала обкатай своё решение локально на тестовых данных. А когда будешь готов, собери из него docker-контейнер и залей его в хранилище системы проведения конкурса. После этого на странице с задачей появится запись о принятом решении и о постановке его в очередь на предварительный обстрел. Будет происходить следующее:

1.  Решение будет закинуто на тестирующую машину с процессором Intel Xeon (4 ядра по 2 GHz) и ОЗУ 4GB. Доступная память = 10 GB HDD.
2.  Оно будет поднято как docker-контейнер (docker run). В случае ошибок запуска, они будут показаны на странице с логом обстрела.
3.  После запуска контейнера в папке /tmp/data будет доступен файл data.zip с архивироваными "боевыми" данными (примерно 200 килобайт для предварительного и 20 мегабайт для полного обстрела) и options.txt. В архиве будут лежать файлы с названиями вида "<имя сущности>_<номер файла>.json". Например:

        ├── users_1.json
        ├── users_2.json
        ├── locations_1.json
        ├── locations_2.json
        ├── visits_1.json
        ├── visits_2.json
        ├── visits_3.json

    Внутри таких файлов - данные в формате JSON. К примеру, данные о путешественниках будут иметь такую структуру:  
    ```json
    {
        "users": [
            {
                "id": 1,
                "email": "robosen@icloud.com",
                "first_name": "Данила",
                "last_name": "Стамленский",
                "gender": "m",
                "birth_date": 345081600
            }, {
                "id": 2,
                "email": "tameerne@yandex.ru",
                "first_name": "Аня",
                "last_name": "Шишкина",
                "gender": "f",
                "birth_date": -1571356800
            }
        ]
    }
    ```
    Для посещений и достопримечательностей - аналогично.
    
4.  У сервера есть фиксированное время до начала обстрела, чтобы залить эти данные в собственную базу данных и подготовить их к обработке (30 секунд для предварительного и 3 минуты для полного обстрела).
5.  По истечении этого времени начинается обстрел сервера запросами из списка [API](#api), который длится 70 секунд для предварительного и 7 минут для рейтингового. Важно - сервер должен слушать 80-й порт, чтобы обстрел прошел успешно! Запросы идут с заголовком Host: travels.com по протоколу HTTP/1.1, один запрос - одно соединение. Сетевые потери полностью отсутствуют.
6.  Результаты и логи обстрела ты увидишь на сайте, на странице с деталями решения в секциях "Обстрел" и "Результаты" соответственно.

При замеченных попытках хакерских атак на сервера проведения конкурса Highload Cup 2017 участнику выдаётся бан, а результаты обстрела не засчитываются.

Обратите внимание! Предварительный обстрел запускается автоматически и нужен для тестирования решения на малой нагрузке. По такому обстрелу показываются результаты в виде графиков, но не считается рейтинг. Для участия в рейтинге, необходимо вручную запустить рейтинговый обстрел, который проводится в гораздо более хардкорных условиях.

Результаты рейтинговых обстрелов всех участников будут сводиться в таблицу на сайте. Лучшие из лучших получат призы!

### 2. Описание предметной области

Как в тестовых, так и в "боевых" данных имеются записи о трех сущностях: User, Location и Visit. Эти сущности описывают путешествия людей по разным достопримечательностям и могут быть основой для небольшого сервиса "В помощь путешественнику". Они содержат данные о собственно профиле пользователя, достопримечательности и посещении конкретным пользователем конкретного места.

В User (Профиль) записаны следующие данные:

*   id - уникальный внешний идентификатор пользователя. Устанавливается тестирующей системой и используется затем, для проверки ответов сервера. 32-разрядное целое число.
*   email - адрес электронной почты пользователя. Тип - unicode-строка длиной до 100 символов. Гарантируется уникальность.
*   first_name и last_name - имя и фамилия соответственно. Тип - unicode-строки длиной до 50 символов.
*   gender - unicode-строка "m" означает мужской пол, а "f" - женский.
*   birth_date - дата рождения, записанная как число секунд от начала UNIX-эпохи по UTC (другими словами - это timestamp).

В Location (Достопримечательность) записаны следующие данные:

*   id - уникальный внешний id достопримечательности. Устанавливается тестирующей системой. 32-разрядное целое число.
*   place - описание достопримечательности. Текстовое поле неограниченной длины.
*   country - название страны расположения. unicode-строка длиной до 50 символов.
*   city - название города расположения. unicode-строка длиной до 50 символов.
*   distance - расстояние от города по прямой в километрах. 32-разрядное целое число.

В Visit (Посещение) записаны следующие данные:

*   id - уникальный внешний id посещения. Устанавливается тестирующей системой. 32-разрядное целое число.
*   location - id достопримечательности. 32-разрядное целое число.
*   user - id путешественника. 32-разрядное целое число.
*   visited_at - дата посещения, timestamp.
*   mark - оценка посещения от 0 до 5 включительно. Целое число.

Все данные сгенерированы случайным образом и не имеют отношения к реальным людям, контактам или местам.

Кроме того, в данных лежит файл options.txt с двумя переменными внутри - timestamp-ом времени генерации и переменной отвечающей за тип обстрела (0 для тестового, 1 для рейтингового)

Один и тот же путешественник может много раз посещать одни и те же достопримечательности с разными оценками.

### 3. Описание необходимого API

API - это методы, которые должен обслуживать разработанный участником сервер, по протоколу HTTP. Маршруты URL строятся в соответствии с парадигмой REST и должны соблюдаться! В угловых скобках представлены части URL, которые могут и будут меняться от запроса к запросу. GET-параметры могут свободно комбинироваться друг с другом либо отсутствовать.

Во всех ответах от сервера учитываются заголовки Content-Type, Content-Length, Connection.

**_Методы выборки данных (GET):_**

1.  Получение данных о сущности: **/\<entity>/\<id>**
    
    В ответе ожидается код 404, если сущности с таким идентификатором нет в данных. Иначе, все собственные поля, включая идентификатор. <entity> принимает одно из значений - users, locations или visits. Пример корректного ответа на запрос:  

    `GET: /users/1`
    ```json
    {
        "id": 1,
        "email": "johndoe@gmail.com",
        "first_name": "John",
        "last_name": "Doe",
        "gender": "m",
        "birth_date": -1613433600
    }
    ```

2.  Получение списка мест, которые посетил пользователь: **/users/\<id>/visits**
  
    В теле ответа ожидается структура `{"visits": [ ... ]}`, отсортированная по возрастанию дат, или ошибка 404/400\. Подробнее - в примере.  
    Возможные GET-параметры:
    *   fromDate - посещения с visited_at > fromDate
    *   toDate - посещения с visited_at < toDate
    *   country - название страны, в которой находятся интересующие достопримечательности
    *   toDistance - возвращать только те места, у которых расстояние от города меньше этого параметра

    Пример корректного ответа на запрос:  

    `GET: /users/1/visits`
    
    ```json
    {
        "visits": [
            {
                "mark": 2,
                "visited_at": 1223268286,
                "place": "Кольский полуостров"
            },
            {
                "mark": 4,
                "visited_at": 958656902,
                "place": "Московский Кремль"
            }
         ]
    }
    ```
    В случае если пользователя с переданным id нет - отдавать 404. Если просто нет посещений, то `{"visits": []}`

3.  Получение средней оценки достопримечательности: **/locations/\<id>/avg**

    В ответе ожидается одно число, с точностью до 5 десятичных знаков (округляется по стандартным правилам округления), либо код 404.  
    Возможные GET-параметры:
    *   fromDate - учитывать оценки только с visited_at > fromDate
    *   toDate - учитывать оценки только до visited_at < toDate
    *   fromAge - учитывать только путешественников, у которых возраст (считается от текущего timestamp) больше этого параметра
    *   toAge - как предыдущее, но наоборот
    *   gender - учитывать оценки только мужчин или женщин

    Пример корректного ответа на запрос:  

    `GET: /locations/1/avg`

    ```json
    {
        "avg": 3.43
    }
    ```
    В случае если места с переданным id нет - отдавать 404. Если по указанным параметрам не было посещений, то `{"avg": 0}`

**_Методы обновления данных (POST):_**

1.  Обновление данных о сущности: **/\<entity>/\<id>**

    В ответе ожидается код 200 с пустым json-ом в теле ответа ("{}"), если обновление прошло успешно, 404 - если запись не существовала в данных или 400, если в теле запроса некорректные данные.  
    Только обновляемые поля и их значения содержатся в теле запроса в формате JSON. id никогда не содержится среди обновляемых полей. Пример тела запроса:  

    `POST: /users/214`

    ```json
    {
        "email": "johndoe@gmail.com",
        "first_name": "Jessie",
        "last_name": "Pinkman",
        "birth_date": 616550400
    }    
    ```

2.  Добавление новой сущности: **/\<entity>/new** 

    В ответе ожидается код 200 с пустым json-ом в теле ответа ("{}"), если создание прошло успешно. В случае некорректных данных - код 400.  
    Обновляемые поля и их значения содержатся в теле запроса в формате JSON. В таких запросах может быть GET-параметр queryId, который надо игнорировать. Пример тела запроса:  

    `POST: /users/new`
    
    ```json
    {
        "id": 245,
        "email": "foobar@mail.ru",
        "first_name": "Маша",
        "last_name": "Пушкина",
        "gender": "f",
        "birth_date": 365299200
    }
    ```
